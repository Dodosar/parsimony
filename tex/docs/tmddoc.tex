\documentclass[11pt]{article}

\title{TMD Documentation}
\author{Adam Yedidia}

\begin{document}
    
\maketitle

The top-level representation is a program written in the TMD language, which is a language designed to give the user a simple interface with which to program a multi-tape, 3-symbol Turing Machine with a function stack. \\

TMD code can be processed in two ways. First, it can be \emph{interpreted}; that is, it can be directly evaluated line-by-line. This is generally done to verify a program's correct behavior, and to correct errors which would result in thrown exceptions in the interpreter but might lead to undefined behavior in the compiled Turing machine (because the compiled Turing machine is optimized for parsimony, whereas the interpreter need not be). \\

Second, TMD code can be \emph{compiled} down to a description of a single-tape, 2-symbol Turing machine. It is highly recommended, however, to first interpret any piece of TMD code before compiling it, because the interpreter is much better for catching programming errors. The compiler is general-purpose and not restricted to compiling the programs discussed in this thesis. It is optimized to minimize the number of states in the resulting Turing machine, not to make the resulting Turing machine time- or space-efficient. \\

A TMD program is contained in a directory. It is a collection of \emph{functions}, each of which contains a sequence of \emph{commands}. Each function is given its own file. Commands are separated by newlines. Each command is given its own line. \\

A TMD program also contains two special files which contain important information about the multi-tape Turing Machine: a file named {\tt functions.tff} and a file named {\tt initvar}. \\ 

What follows is a brief description of the syntax of the TMD language. A much more detailed description is available at~\cite{github}. The brief description contained here should be enough for a reader to gain a reasonable understanding of the programs written for this paper; any reader wishing to write her own programs is strongly encouraged read the more detailed documentation before proceeding.

\section{Function Files}

Most of the logic contained within a TMD program lies in its function files. TMD functions can make reference to the tapes in the machine and read the symbol under the head of each tape, much as a standard multi-tape TM can. In addition, TMD functions can call other TMD functions, pushing those functions to the top of the stack. Finally, TMD functions can return, popping themselves from the function stack. \\

A TMD function file is composed of four kinds of lines: an input line, calls to other functions, tape commands, and return statements. 

\subsection{The Input Line}

Every TMD function file begins with an input line. TMD function files cannot contain more than one input line. The input line describes what tapes are going to be passed in as arguments to the function, and will therefore be readable and writeable within the function. An example of an input line might be: \\ \\
\texttt{input x y z}

\subsection{Labels}

Any line in a TMD function other than the input line may be preceded by a \emph{label}. A label takes the following form: \\ \\
~[alphanumeric string]\texttt{:} [line of code] \\

A label is an indicator attached to a line of code. Using tape commands, the line of code can be referenced in order to jump to the labelled line of code. The label can also be given a descriptive name that helps to explain the purpose of the line. This is perfectly legitimate even if the programmer has no intention of jumping to the line later; the addition of a label results in no additional states in the compiled program.

\subsection{Function Calls}

Function calls call a TMD function defined within the directory, placing the newborn function call at the top of the function stack with a new program counter of 0 (indicating that the first line of the called function should be the first to be read). The return address of the function call is the line following the function call. \\

Function calls have the following form: \\ \\
\texttt{function }[function name]([argument name]$)^*$ \\

When a function call is executed, the function that is described by the file [function name]\texttt{.tmd} is executed, starting with its top line. If no file [function name]\texttt{.tmd} exists within the program directory, an error is thrown at compile-time or upon interpreting the function call. \\ 

An example of a function call might be: \\ \\
\texttt{function add x y}

\subsection{Tape Commands}

Tape commands begin with a marker that indicates which tape is going to be used in the command. They then explain what to do if each possible symbol is read.

In TMD, there are three legal tape symbols; they are \texttt{1}, \texttt{E}, and \texttt{\_}. \texttt{\_} is the empty symbol (the only one which can appear an infinite number of times on any tape). Furthermore, in TMD, it is a requirement that each tape always have the form $(\texttt{\_})^{\infty}(\texttt{1}|\texttt{E})^{+}(\texttt{\_})^{\infty}$ (here, the $(.)^+$ operation denotes repetition any positive number of times, and the $(.)^\infty$ operation denotes repetition an infinite number of times). This requirement is for ease of compilation down to a single-tape TM; later, when the TMD is compiled down a Turing machine and that Turing machine is searching the registers for a register that matches a specific ID, the search will assume that the register organization will alternate (identifier, value, identifier, value) and that a value will be represented as a ``chunk'' of 1's and E's. This is why the above requirement must be respected. \\

Tape commands have the following form: \\

\texttt{[}[variable name]\texttt{]} ([symbol read] \texttt{(} [list of reactions] \texttt{)}$)^*$ \\

The list of reactions is a series of words separated by commas and encompassed by parentheses. Different reactions are separated by semicolons. These reactions can include what direction to move, what symbol to write, and what line to jump to after execution. \\

The symbols \textrm{1}, \textrm{E}, and \textrm{\_} are used to denote what symbol to write on the tape after reading. The symbols \textrm(R}, \textrm{L}, and \textrm{-} are used to denote what direction the head should move after writing (with \texttt{R} indicating a move rightward, \texttt{L} indicating a move leftward, and \textrm{-} indicating a command to remain stationary). Any other string denotes a label, indicating a jump to the relevant label. Therefore, TMD programmers should not name their labels \textrm{R} (for example)! This will confuse the compiler. Additionally, TMD programmers should not put two conflicting reactions in the same command, such as two different move commands. \\

Any type of reaction that is excluded from a parenthetical will be presumed to be the default. The default for each type is: \\ \\
-Symbol written: whatever symbol was read. \\
-Head move direction: \texttt{-} (in other words, no move). \\
-Jump: go to the next line. \\

As an example, the reaction \texttt{1 (E, -, LABEL)} would indicate that in response to reading a \texttt{1} on the tape, an \texttt{E} should be written, the head should not move, and the next line of code to be executed should be labelled LABEL. It would have identical behavior to the reaction \texttt{1 (E, LABEL)}, because \texttt{-} is the default behavior for which direction to move the head. \\

An example of a full tape command might be the following: \\
\texttt{FIND_E: [x] 1 (R, FIND_E); E ()} \\

This tape command would indicate that on the tape named \texttt{x}, if a \texttt{1} is read off the tape, then a \texttt{1} should be written back onto the tape (because that is the default), the head should move right, and the line of code should be re-executed. If an \texttt{E} is read off the tape, then an \texttt{E} should be written back onto the tape, the head should not move, and execution should proceed to the next line of code (because those are the defaults). Because no reaction is provided in the case where a \texttt{\_} is read off the tape, an error will be thrown if that is the symbol that is read, both in interpretation and in the Turing machine that results from compilation. \\

It should be noted that while there is no difference between explicitly writing out the default and leaving it implied for head moves and for symbol writes (so, for example, a TMD program including the line \texttt{[x] 1 (1)} will compile to an identical machine as a program including the line \texttt{[x] 1 ()}), there \emph{is} a difference between explicitly writing out the default and leaving it implied for jumps. This difference manifests itself only in terms of parsimony and not in terms of behavior, and therefore is only visible when compiling the program, not when interpreting it (since during interpretation, only behavior matters). This is because while in the case of an explicit jump, the jump address must be written out onto the tape, there is a much shorter abbreviation for the default if it is simply a jump to the next line. Figure~\ref{fig:defaultjump} shows this case in more detail.

\begin{figure} 
\begin{center} 
\includegraphics[scale=0.4]{figs/defaultjump.png}
\caption{This figure shows two code snippets. The two snippets will have identical behavior when interpreted or compiled, because the default is to jump to the next line. However, the bottom snippet will compile to a more parsimonious Turing machine (albeit one that behaves identically) because the compiler will know to use the default abbreviation for ``go to the next line,'' whereas in the top case the compiler will have to write out the jump address for the line labelled \texttt{NEXT_LINE}. Therefore, it is recommended that programmers concerned with parsimony use the approach shown by the bottom snippet. \label{fig:defaultjump}} 
\end{center} 
\end{figure}

\subsection{Return Statements}

Return statements indicate the end of a function's execution. After a function returns, that function's call is popped off the function stack, and execution continues at the line of code following the line that called the function that just returned. If the function stack is empty, and there is no function to return to, 



\end{document}